package Analyzer;

import java_cup.runtime.*;
import java.util.LinkedList;
import AST.*;
import AST.Expresiones.*;
import AST.Sentencias.*;

parser code
{:
    /* RAIZ */
    Principal principal;

    public void setPrincipal(Principal principal){
        this.principal = principal;
    }

    /**
    *   Metodo que retorna la raiz del arbol
    **/
    public Principal getPrincipal(){
        return this.principal;
    }
    
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/
    public void syntax_error(Symbol s){
        System.out.println("Error sintactico en la linea: " + (s.left) +" Columna: " +s.right+ ". No se esperaba este componente: " + s.value+"."); 
        Token token = new Token();
        token.lexema = s.value+"";
        token.componenteLexico = "Sintáctico";
        token.descripcion = "No se esperaba: "+s.value;
        token.columna = s.right+1+"";
        token.fila = s.left+1+"";
        this.principal.addError(token);
    }
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error Sintactico irrecuperable en la Lienea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
        Token token = new Token();
        token.lexema = s.value+"";
        token.componenteLexico = "Sintáctico inrecuperable";
        token.descripcion = "No se esperaba: "+s.value;
        token.columna = s.right+1+"";
        token.fila = s.left+1+"";
        this.principal.addError(token);
    }
:}

terminal String res_null, res_false, res_true,

res_function, res_in, 

res_if, res_else, res_while, res_for, res_switch, res_case, res_default, res_break, res_continue, res_return, res_do,

l_corchete, r_corchete, l_llave, r_llave, l_parent, r_parent,
coma, puntocoma, igualigual, igual, mas, menos, por, potencia, modular, div, ternario, mayorigual, mayor, menorigual, menor, diferente,
and, or, not, dospuntos,

numero, doble, id, cadena,

UMINUS,UPLUS
;

non terminal S
;

non terminal PARAMETROS,
LISTA_PARAMETROS, PARAMETRO,
RETURN, IF, ELSE, WHILE, DOWHILE, FOR, SWITCH, LISTA_CASOS, DEFAULT, PUEDE_SEMICOLON
;

non terminal LinkedList<Expresion> LISTA_E;
non terminal LinkedList<Nodo> LISTA_BLOQUES, BLOQUES, DECLARACIONES;
non terminal Nodo DECLARACION, INSTRUCCION;
non terminal Expresion CONSTANTE, E, LLAMADA, BINARIA, UNARIA, ARITMETICA, LOGICA, RELACIONAL, TERNARIA;
non terminal Sentencia SENTENCIA, FUNCION, VARIABLE;

precedence left ternario;
precedence left or;
precedence left and;
precedence left diferente,igualigual;
precedence nonassoc mayor,mayorigual,menor,menorigual;
precedence left mas,menos;
precedence left por,div,modular;
precedence left potencia;
precedence right not,UMINUS,UPLUS;
precedence left l_parent,r_parent,l_corchete,r_corchete;

start with S;

S ::= DECLARACIONES:a
    {:
        principal.setNodos(a);
    :}
;

DECLARACIONES::= DECLARACIONES:a DECLARACION:b
    {:
        RESULT = a;
        a.add(b);
    :}
    | DECLARACION:a
    {:
        RESULT = new LinkedList<Nodo>();
        RESULT.add(a);
    :}
;

DECLARACION ::= FUNCION:a
    {:
        RESULT = a;
    :}
    | SENTENCIA:a
    {:
        RESULT = a;
    :}
    | INSTRUCCION:a PUEDE_SEMICOLON
    {:
        RESULT = a;
    :}
;

VARIABLE ::= id:a igual E:b 
    {:
        RESULT = new Declaracion(a,b,aleft+1,aright+1);
    :}
;

FUNCION ::= id:a igual res_function l_parent PARAMETROS:b r_parent l_llave BLOQUES:c r_llave
    {:
    :}
    | id:a igual l_parent PARAMETROS:b r_parent igual mayor l_llave BLOQUES:c r_llave
    {:
    :}
;

PARAMETROS ::= LISTA_PARAMETROS:a
    {:
    :}
    | /* empty */
    {:
    :}
;

LISTA_PARAMETROS ::= LISTA_PARAMETROS:a coma PARAMETRO:b
    {:
    :}
    | PARAMETRO:a
    {:
    :}
;

PARAMETRO ::= E:a 
    {:
    :}
    | id:a igual E:b
    {:
    :}
;

BLOQUES ::= LISTA_BLOQUES:a
    {:
        RESULT = a;
    :}
    | /* empty */
    {:
        RESULT = new LinkedList<Nodo>();
    :}
;

LISTA_BLOQUES ::= LISTA_BLOQUES:a INSTRUCCION:b PUEDE_SEMICOLON
    {:
        RESULT = a;
        RESULT.add(b);
    :}
    | LISTA_BLOQUES:a SENTENCIA:b
    {:
        RESULT = a;
        RESULT.add(b);
    :}
    | SENTENCIA:a 
    {:
        RESULT = new LinkedList<Nodo>();
        RESULT.add(a);
    :}
    | INSTRUCCION:a PUEDE_SEMICOLON
    {:
        RESULT = new LinkedList<Nodo>();
        RESULT.add(a);
    :}
;

SENTENCIA ::= IF:a
    {:
    :}
    | SWITCH:a
    {:
    :}
    | WHILE:a
    {:
    :}
    | DOWHILE:a
    {:
    :}
    | FOR:a
    {:
    :}
;

INSTRUCCION ::= res_break:a
    {:
    :}
    | res_continue:a
    {:
    :}
    | LLAMADA:a
    {:
        RESULT = a;
    :}
    | VARIABLE:a
    {:
        RESULT = a;
    :}
    | RETURN:a
    {:
        //RESULT = a;
    :}
;

RETURN ::= res_return l_parent E:a r_parent
    {:
    :}
    | res_return
    {:
    :}
;

IF ::= res_if l_parent E:a r_parent l_llave BLOQUES:b r_llave
    {:
    :}
    | res_if l_parent E:a r_parent l_llave BLOQUES:b r_llave ELSE:c
    {:
    :}
;

ELSE ::= res_else IF:a
    {:
    :}
    | res_else:a l_llave BLOQUES:b r_llave
    {:
    :}
;

WHILE ::= res_while l_parent E:a r_parent l_llave BLOQUES:b r_llave
    {:
    :}
;

DOWHILE ::= res_do l_llave BLOQUES:a r_llave res_while l_parent E:b r_parent puntocoma
    {:
    :}
;

FOR ::= res_for l_parent id:a res_in E:b r_parent l_llave BLOQUES:c r_llave
    {:
    :}
;

SWITCH ::= res_switch l_parent E:a r_parent l_llave LISTA_CASOS:b DEFAULT:c r_llave
    {:
    :}
;

LISTA_CASOS ::= LISTA_CASOS:a res_case E:b dospuntos BLOQUES:c
    {:
    :}
    | res_case E:a dospuntos BLOQUES:b
    {:
    :}
;

DEFAULT ::= res_default:a dospuntos BLOQUES:b
    {:
    :}
    | /*empty*/
    {:
    :}
;

LISTA_E ::= LISTA_E:a coma E:b
    {:
        RESULT = a;
        RESULT.add(b);
    :}
    | E:a
    {:
        RESULT = new LinkedList<Expresion>();
        RESULT.add(a);
    :}
;

E ::= CONSTANTE:a    
    {:
        RESULT = a;
    :}
    | BINARIA:a
    {:
        RESULT = a;
    :}
    | UNARIA:a
    {:
        RESULT = a;
    :}
    | TERNARIA:a 
    {:
        RESULT = a;
    :}
    | LLAMADA:a
    {:
        RESULT = a;
    :}
    | l_parent E:a r_parent
    {:
        RESULT = a;
    :}
    /*
    | DECLARACION_ARREGLO:a
    {:
    :}
    */
;

TERNARIA ::= E:a ternario E:b dospuntos E:c 
{:
:}
;

LLAMADA ::= id:a l_parent LISTA_E:b r_parent
    {:
        RESULT = new Llamada(a,b,aleft+1,aright+1);
    :}
;

CONSTANTE ::= numero:a
    {:
        RESULT = new Primitivo(Integer.parseInt(a),Expresion.TIPO_PRIMITIVO.INTEGER,aleft+1,aright+1);
    :}
    | res_true:a
    {:
        RESULT = new Primitivo(true,Expresion.TIPO_PRIMITIVO.BOOLEAN,aleft+1,aright+1);
    :}
    | res_false:a
    {:
        RESULT = new Primitivo(false,Expresion.TIPO_PRIMITIVO.BOOLEAN,aleft+1,aright+1);
    :}
    | doble:a
    {:
        RESULT = new Primitivo(Double.parseDouble(a),Expresion.TIPO_PRIMITIVO.DOUBLE,aleft+1,aright+1);
    :}
    | res_null:a
    {:
        RESULT = new Primitivo("",Expresion.TIPO_PRIMITIVO.STRING,aleft+1,aright+1);
    :}
    | cadena:a
    {:
        String cad = a.substring(1,a.length());
        cad = cad.substring(0,cad.length()-1);
        RESULT = new Primitivo(cad,Expresion.TIPO_PRIMITIVO.STRING,aleft+1,aright+1);
    :}
    | id:a
    {:
        RESULT = new Primitivo(a,Expresion.TIPO_PRIMITIVO.VARIABLE,aleft+1,aright+1);
    :}
    | res_default:a
    {:
        RESULT = new Primitivo("",Expresion.TIPO_PRIMITIVO.DEFAULT,aleft+1,aright+1);
    :}
;

BINARIA ::= ARITMETICA:a
    {:
        RESULT = a;
    :}
    | LOGICA:a
    {:
        RESULT = a;
    :}
    | RELACIONAL:a
    {:
        RESULT = a;
    :}
;

UNARIA::= menos E:a
    {:
    :}
    %prec UMINUS
    | not E:a
    {:
    :}
    | mas E:a
    {:
    :}
    %prec UPLUS
;

ARITMETICA ::= E:a mas E:b
    {:
    :}
    | E:a menos E:b
    {:
    :}
    | E:a por E:b
    {:
    :}
    | E:a div E:b
    {:
    :}
    | E:a potencia E:b
    {:
    :}
    | E:a modular E:b
    {:
    :}
;

LOGICA ::= E:a or E:b
    {:
    :}
    | E:a and E:b
    {:
    :}
;

RELACIONAL ::= E:a menor E:b
    {:
    :}
    | E:a menorigual E:b
    {:
    :}
    | E:a mayor E:b
    {:
    :}
    | E:a mayorigual E:b
    {:
    :}
    | E:a igualigual E:b
    {:
    :}
    | E:a diferente E:b
    {:
    :}
;

PUEDE_SEMICOLON ::= puntocoma
    | /*empty*/
;