package Analyzer;

import java_cup.runtime.*;
import java.util.LinkedList;

parser code
{:
    /* RAIZ */

    /**
    *   Metodo que retorna la raiz del arbol
    **/
    /*
    public Principal GetAst(){
        return p;
    }
    */
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/
    public void syntax_error(Symbol s){
            System.out.println("Error sintactico en la linea: " + (s.left) +" Columna: " +s.right+ ". No se esperaba este componente: " + s.value+"."); 
            
           
 }
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            System.out.println("Error Sintactico irrecuperable en la Lienea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido.");
           
 }
:}

terminal String res_null, res_false, res_true,

res_function, res_in, 

res_if, res_else, res_while, res_for, res_switch, res_case, res_default, res_break, res_continue, res_return, res_do,

l_corchete, r_corchete, l_llave, r_llave, l_parent, r_parent,
coma, puntocoma, igualigual, igual, mas, menos, por, potencia, modular, div, ternario, mayorigual, mayor, menorigual, menor, diferente,
and, or, not, dospuntos,

numero, doble, id, cadena,

UMINUS,UPLUS
;

non terminal S
;

non terminal DECLARACIONES, DECLARACION, VARIABLE, FUNCION, PARAMETROS,
LISTA_PARAMETROS, PARAMETRO, BLOQUES, LISTA_BLOQUES, SENTENCIA, INSTRUCCION,
RETURN, IF, ELSE, WHILE, DOWHILE, FOR, SWITCH, LISTA_CASOS, DEFAULT,
LISTA_E, E, LLAMADA, CONSTANTE, BINARIA, UNARIA, ARITMETICA, LOGICA,
RELACIONAL, PUEDE_SEMICOLON, TERNARIA
;

precedence left ternario;
precedence left or;
precedence left and;
precedence left diferente,igualigual;
precedence nonassoc mayor,mayorigual,menor,menorigual;
precedence left mas,menos;
precedence left por,div,modular;
precedence left potencia;
precedence right not,UMINUS,UPLUS;
precedence left l_parent,r_parent,l_corchete,r_corchete;

start with S;

S ::= DECLARACIONES:a
    {:
    :}
;

DECLARACIONES::= DECLARACIONES:a DECLARACION:b
    {:
    :}
    | DECLARACION:a
    {:
    :}
;

DECLARACION ::= FUNCION:a
    {:
    :}
    | SENTENCIA:a
    {:
    :}
    | INSTRUCCION:a PUEDE_SEMICOLON
    {:
    :}
;

VARIABLE ::= id:a igual E:b 
    {:
    :}
;

FUNCION ::= id:a igual res_function l_parent PARAMETROS:b r_parent l_llave BLOQUES:c r_llave
    {:
    :}
    | id:a igual l_parent PARAMETROS:b r_parent igual mayor l_llave BLOQUES:c r_llave
    {:
    :}
;

PARAMETROS ::= LISTA_PARAMETROS:a
    {:
    :}
    | /* empty */
    {:
    :}
;

LISTA_PARAMETROS ::= LISTA_PARAMETROS:a coma PARAMETRO:b
    {:
    :}
    | PARAMETRO:a
    {:
    :}
;

PARAMETRO ::= id:b
    {:
    :}
    | res_default
    {:
    :}
;

BLOQUES ::= LISTA_BLOQUES:a
    {:
    :}
    | /* empty */
    {:
    :}
;

LISTA_BLOQUES ::= LISTA_BLOQUES:a INSTRUCCION:b PUEDE_SEMICOLON
    {:
    :}
    | LISTA_BLOQUES:a SENTENCIA:b
    {:
    :}
    | SENTENCIA:a 
    {:
    :}
    | INSTRUCCION:a PUEDE_SEMICOLON
    {:
    :}
;

SENTENCIA ::= IF:a
    {:
    :}
    | SWITCH:a
    {:
    :}
    | WHILE:a
    {:
    :}
    | DOWHILE:a
    {:
    :}
    | FOR:a
    {:
    :}
;

INSTRUCCION ::= res_break:a
    {:
    :}
    | res_continue:a
    {:
    :}
    | LLAMADA:a
    {:
    :}
    | VARIABLE:a
    {:
    :}
    | RETURN:a
    {:
    :}
;

RETURN ::= res_return l_parent E:a r_parent
    {:
    :}
    | res_return
    {:
    :}
;

IF ::= res_if l_parent E:a r_parent l_llave BLOQUES:b r_llave
    {:
    :}
    | res_if l_parent E:a r_parent l_llave BLOQUES:b r_llave ELSE:c
    {:
    :}
;

ELSE ::= res_else IF:a
    {:
    :}
    | res_else:a l_llave BLOQUES:b r_llave
    {:
    :}
;

WHILE ::= res_while l_parent E:a r_parent l_llave BLOQUES:b r_llave
    {:
    :}
;

DOWHILE ::= res_do l_llave BLOQUES:a r_llave res_while l_parent E:b r_parent puntocoma
    {:
    :}
;

FOR ::= res_for l_parent id:a res_in E:b r_parent l_llave BLOQUES:c r_llave
    {:
    :}
;

SWITCH ::= res_switch l_parent E:a r_parent l_llave LISTA_CASOS:b DEFAULT:c r_llave
    {:
    :}
;

LISTA_CASOS ::= LISTA_CASOS:a res_case E:b dospuntos BLOQUES:c
    {:
    :}
    | res_case E:a dospuntos BLOQUES:b
    {:
    :}
;

DEFAULT ::= res_default:a dospuntos BLOQUES:b
    {:
    :}
    | /*empty*/
    {:
    :}
;

LISTA_E ::= LISTA_E:a coma E:b
    {:
    :}
    | E:a
    {:
    :}
;

E ::= CONSTANTE:a    
    {:
    :}
    | BINARIA:a
    {:
    :}
    | UNARIA:a
    {:
    :}
    | TERNARIA:a 
    {:
    :}
    | LLAMADA:a
    {:
    :}
    | l_parent E:a r_parent
    {:
    :}
    /*
    | DECLARACION_ARREGLO:a
    {:
    :}
    */
;

TERNARIA ::= E:a ternario E:b dospuntos E:c 
{:
:}
;

LLAMADA ::= id:a l_parent LISTA_E:b r_parent
    {:
    :}
;

CONSTANTE ::= numero:a
    {:
    :}
    | res_true
    {:
    :}
    | res_false
    {:
    :}
    | doble:a
    {:
    :}
    | res_null:a
    {:
    :}
    | cadena:a
    {:
    :}
;

BINARIA ::= ARITMETICA:a
    {:
    :}
    | LOGICA:a
    {:
    :}
    | RELACIONAL:a
    {:
    :}
;

UNARIA::= menos E:a
    {:
    :}
    %prec UMINUS
    | not E:a
    {:
    :}
    | mas E:a
    {:
    :}
    %prec UPLUS
;

ARITMETICA ::= E:a mas E:b
    {:
    :}
    | E:a menos E:b
    {:
    :}
    | E:a por E:b
    {:
    :}
    | E:a div E:b
    {:
    :}
    | E:a potencia E:b
    {:
    :}
    | E:a modular E:b
    {:
    :}
;

LOGICA ::= E:a or E:b
    {:
    :}
    | E:a and E:b
    {:
    :}
;

RELACIONAL ::= E:a menor E:b
    {:
    :}
    | E:a menorigual E:b
    {:
    :}
    | E:a mayor E:b
    {:
    :}
    | E:a mayorigual E:b
    {:
    :}
    | E:a igualigual E:b
    {:
    :}
    | E:a diferente E:b
    {:
    :}
;

PUEDE_SEMICOLON ::= puntocoma
    | /*empty*/
;