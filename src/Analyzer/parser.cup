package Analyzer;

import java_cup.runtime.*;
import Interpreter.INSTRUCCION.*;
import Interpreter.Objeto.*;
import Interpreter.Operation.*;
import Principal.*;
import java.util.LinkedList;

parser code
{:
    /* RAIZ */
    Principal p;

    /**
    *   Metodo que retorna la raiz del arbol
    **/
    public Principal GetAst(){
        return p;
    }
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/
    public void syntax_error(Symbol s){
            System.out.println("Error sintactico en la linea: " + (s.left) +" Columna: " +s.right+ ". No se esperaba este componente: " + s.value+"."); 
            Singleton.getInstance().addError(s.left,s.right,"Sintactico : No se esperaba este componente: " + s.value+".");
           
 }
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            System.out.println("Error Sintactico irrecuperable en la Lienea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido.");
            Singleton.getInstance().addError(s.left,s.right,"Sintactico : No se esperaba este componente: " + s.value+".");
           
 }
:}

terminal String res_null,res_if,res_while,res_for,res_switch,res_case,res_default,
res_break,res_continue,res_final,res_import,res_return,res_when,res_string,
l_corchete,r_corchete,l_llave,r_llave,l_parent,r_parent,coma,puntocoma,igualigual,diferente,mas,menos,por,potencia,modular,div,
mayor,mayorigual,menor,menorigual,masmas,menosmenos
and,or,not,punto,dospuntos,
numero,doble,cadena,caracter,id,
res_else,UMINUS,UPLUS,res_mian, res_print, res_println, res_true, res_false;

non terminal S;

non terminal LISTA_INSTRUCCIONES,BLOQUES,LISTA_CASOS,DECLARACIONES,
INSTRUCCION,IF,res_return,res_break,res_continue,SWITCH,WHILE,FOR,ASIGNACION,LLAMADA,ELSE,DEFAULT,SENTENCIA,
VARIABLE,FUNCION,DECLARACION,IMPORT,StructDef,ConstDef,ATRIBUTO,PARAMETRO,
LISTA_ATRIBUTOS,LISTA_PARAMETROS,PARAMETROS,TIPO,LISTA_ID,LISTA_E,CONSTANTE,BINARIA,LOGICA,ARITMETICA,
RELACIONAL,UNARIA,POST_E,ACCESO,E,DECLARACION_ARREGLO,ARREGLO_PARAM,LISTA_ARREGLO;

precedence left or;
precedence left and;
precedence left diferente,igualigual;
precedence nonassoc mayor,mayorigual,menor,menorigual;
precedence left mas,menos;
precedence left por,div,modular;
precedence left potencia;
precedence right not,UMINUS,UPLUS,masmas,menosmenos;
precedence left l_parent,r_parent,l_corchete,r_corchete;

start with S;

S ::= DECLARACIONES:a
    {:
        p = new Principal(a);
    :}
;

DECLARACIONES::= DECLARACIONES:a DECLARACION:b
    {:
    :}
    | DECLARACION:a
    {:
    :}
;

DECLARACION ::= VARIABLE:a
    {:
    :}
    | FUNCION:a
    {:
    :}
;

VARIABLE ::= 
;

FUNCION ::= res_main id:a l_parent PARAMETROS:b r_parent l_llave BLOQUES:c r_llave
    {:
    :}
    | TIPO:a id:b l_parent PARAMETROS:c r_parent l_llave BLOQUES:d r_llave
    {:
    :}
    | TIPO:a ARREGLO_PARAM:b id:c l_parent PARAMETROS:d r_parent l_llave BLOQUES:e r_llave
    {:
    :}
;

PARAMETROS ::= LISTA_PARAMETROS:a
    {:
    :}
    | /* empty */
    {:
    :}
;

LISTA_PARAMETROS ::= LISTA_PARAMETROS:a coma PARAMETRO:b
    {:
    :}
    | PARAMETRO:a
    {:
    :}
;

PARAMETRO ::= TIPO:a id:b
    {:
    :}
    | TIPO:a id:b ARREGLO_PARAM:c
    {:
    :}
;

BLOQUES ::= LISTA_INSTRUCCIONES:a
    {:
    :}
    | LISTA_SENTENCIAS:a
    {:
    :}
    | /* empty */
    {:
    :}
;

LISTA_SENTENCIAS ::= LISTA_SENTENCIAS:a SENTENCIA:b
    {:
    :}
    | SENTENCIA:a
    {:
    :}
;

LISTA_INSTRUCCIONES ::= LISTA_INSTRUCCIONES:a INSTRUCCION:b
    {:
    :}
    | INSTRUCCION:a
    {:
    :}
;

SENTENCIA ::= IF:a
    {:
    :}
    | SWITCH:a
    {:
    :}
    | WHILE:a
    {:
    :}
    | FOR:a
    {:
    :}

INSTRUCCION ::= res_return:a
    {:
    :}
    | res_break:a
    {:
    :}
    | res_continue:a
    {:
    :}
    
    | ASIGNACION:a puntocoma
    {:
    :}
    | LLAMADA:a
    {:
    :}
    | VARIABLE:a
    {:
    :}
    | SENTENCIA:a
    {:
    :}
    | InputOutputDef:a
    {:
    :}
;

res_return ::= res_return E:a puntocoma
    {:
    :}
    | res_return:a puntocoma
    {:
    :}
;

res_break ::= res_break:a puntocoma
    {:
    :}
;

res_continue ::= res_continue:a puntocoma
    {:
    :}
;

IF ::= res_if l_parent E:a r_parent l_llave BLOQUES:b r_llave
    {:
    :}
    | res_if l_parent E:a r_parent l_llave BLOQUES:b r_llave ELSE:c
    {:
    :}
;

ELSE ::= res_else IF:a
    {:
    :}
    | res_else:a l_llave BLOQUES:b r_llave
    {:
    :}
;

WHILE ::= res_while l_parent E:a r_parent l_llave BLOQUES:b r_llave
    {:
    :}
;

RepeatDef ::= REPEATR l_llave BLOQUES:a r_llave res_when l_parent E:b r_parent puntocoma
    {:
    :}
;

FOR ::= res_for l_parent VARIABLE:a E:b puntocoma ASIGNACION:c r_parent l_llave BLOQUES:d r_llave
    {:
    :}
    | res_for l_parent ASIGNACION:a puntocoma E:b puntocoma ASIGNACION:c r_parent l_llave BLOQUES:d r_llave
    {:
    :}
;

SWITCH ::= res_switch l_parent E:a r_parent l_llave LISTA_CASOS:b DEFAULT:c r_llave
    {:
    :}
;

LISTA_CASOS ::= LISTA_CASOS:a res_case E:b dospuntos BLOQUES:c
    {:
    :}
    | res_case E:a dospuntos BLOQUES:b
    {:
    :}
;

DEFAULT ::= res_default:a dospuntos BLOQUES:b
    {:
    :}
    | /*empty*/
    {:
    :}
;

LISTA_E ::= LISTA_E:a coma E:b
    {:
    :}
    | E:a
    {:
    :}
;

E ::= CONSTANTE:a    
    {:
    :}
    | BINARIA:a
    {:
    :}
    | UNARIA:a
    {:
    :}
    | ACCESO:a
    {:
    :}
    | l_parent E:a r_parent
    {:
    :}
    | DECLARACION_ARREGLO:a
    {:
    :}
;

CONSTANTE ::= numero:a
    {:
    :}
    | res_true
    {:
    :}
    | res_false
    {:
    :}
    | doble:a
    {:
    :}
    | res_null:a
    {:
    :}
    | cadena:a
    {:
    :}
;

BINARIA ::= ARITMETICA:a
    {:
    :}
    | LOGICA:a
    {:
    :}
    | RELACIONAL:a
    {:
    :}
    | POST_E:a
    {:
    :}
;

UNARIA::= menos E:a
    {:
    :}
    %prec UMINUS
    | not E:a
    {:
    :}
    | mas E:a
    {:
    :}
    %prec UPLUS
;

POST_E ::= E:a masmas
    {:
    :}
    | E:a menosmenos
    {:
    :}
;

ARITMETICA ::= E:a mas E:b
    {:
    :}
    | E:a menos E:b
    {:
    :}
    | E:a por E:b
    {:
    :}
    | E:a div E:b
    {:
    :}
    | E:a potencia E:b
    {:
    :}
    | E:a modular E:b
    {:
    :}
;

LOGICA ::= E:a or E:b
    {:
    :}
    | E:a and E:b
    {:
    :}
;

RELACIONAL ::= E:a menor E:b
    {:
    :}
    | E:a menorigual E:b
    {:
    :}
    | E:a mayor E:b
    {:
    :}
    | E:a mayorigual E:b
    {:
    :}
    | E:a igualigual E:b
    {:
    :}
    | E:a diferente E:b
    {:
    :}
;

LISTA_ID ::= LISTA_ID:a coma id:b
    {:
    :}
    | id:a
    {:
    :}
;
